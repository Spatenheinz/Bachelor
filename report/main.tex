% Created 2021-02-25 Thu 14:17
% Intended LaTeX compiler: pdflatex
\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\input{baseHeader.tex}
\assignment{} \subtitle{} \date{12 06 2021} \advisor{Advisor: Kenneth Skovhede} \frontpage{}
\author{Jacob Herbst (mwr148), Jonas Flach Jensen ()}
\date{\today}
\title{Crypto in SME for FPGA}
\hypersetup{
 pdfauthor={Jacob Herbst (mwr148), Jonas Flach Jensen ()},
 pdftitle={Crypto in SME for FPGA},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.1 (Org mode 9.5)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents

\newpage
\section{Introduction}
\label{sec:orge7f229a}

\section{Background}
\label{sec:orga206965}

\subsection{FPGA}
\label{sec:orgcccb15d}

\subsection{SME and CSP}
\label{sec:org31cfa11}
Synchronous Message Exchange (SME) is a programming model to enable FPGA development using high-level languages. SME is based on Communicating Sequential Processes (CSP) and at its core constructs as a strict subset of said process calculi, making use of the elements which has proven useful in hardware design\cite{sme}. Using the following concepts from the CSP model, SME can be derived:
\begin{itemize}
\item A program consists of a set of named processes.
\item Each process runs on its own processor with no form of sharing with other processes.
\item Concurrent processes can communicate using message passing with a \texttt{send(!)} and a \texttt{receive(?)} command. This message passing is Blocking and Non-buffered.
\end{itemize}
Without going into too much detail about the syntax and semantics of CSP\cite{CSP}, we can use the following syntax to describe a program.
\begin{description}
\item[{\textasciitilde{}x}] PROCESS\textasciitilde{}, which assigns the PROCESS to the name x.
\item \texttt{x.in} is a compound name similar to an object field \texttt{in} of the object. Notice this abstraction makes the connection to SME and its C\# implementation more obvious.
\item \texttt{x.out!y.in} This is the sending message passing. It will send y.in to x.out.
\item \texttt{x.out?y.in}. This is the receiving message passing. It will read x.out to y.in.
\item \texttt{x || y} will denote two concurrent processes, x and y.
\end{description}
Later we will show this can easily show abstractions of algorithms when using SME. SME has a similar notion of processes. There exist two types of SME processes, \texttt{simple process} and a \texttt{simulation process}. Of these, the simple process corresponds to a process in CSP as described above. Each simple process in SME will only share communication channels and constants with the other processes. For the communications channels, SME extends the concepts from CSP by using buses. Instead of using explicit naming for sources and destinations, each process will consist of a set of input and output busses that it can read and write to, respectively. Furthermore, these buses use broadcasting as means of synchronization instead of the blocking non-buffered approach.  The broadcasting happens every clock-cycle on the internal clock.
A bus is essentially just a collection of fields that can be read and written to depending on the process's access, merely a data transfer object. Here the syntax described above comes in hand. \texttt{message.text} would thus be the text field of the bus \texttt{message}. Corollary, we could define a very minimal process as such \texttt{[messageIn.text?messageOut.text]}, which would read the text field from the \texttt{messageIn} input bus and write it to the \texttt{messageOut} output bus. From these abstractions, one might be able to see how this effortlessly coincides with the hardware model.
\subsection{A crypto library}
\label{sec:org91f869f}

\subsubsection{Hashing}
\label{sec:org1b3aca9}

\subsubsection{MD5}
\label{sec:org952fd00}

\section{Implementation}
\label{sec:org6f71d42}

\subsection{Approaches}
\label{sec:orgb42831d}

\subsubsection{naive}
\label{sec:org5fb0dbf}

\subsubsection{pipelined}
\label{sec:org3b2f4bd}

\subsection{MD5}
\label{sec:orgf1b8b92}

\subsubsection{naive}
\label{sec:org092f1e5}

\subsubsection{pipeline 1}
\label{sec:org0d26415}

\section{Benchmarks}
\label{sec:org58685a5}

\section{Discussion}
\label{sec:org23a43ee}

\section{Conclusion}
\label{sec:org73e5435}

\bibliographystyle{unsrt}
\bibliography{ref}

\begin{appendix}

\end{appendix}
\end{document}
