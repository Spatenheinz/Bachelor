* Discussion
SME has worked well for us as a tool for developing FPGAs, as the results show even naive implementations uses few resources
and although they weren't as fast as their CPU counterparts they weren't far behind. The major problems we encountered using SME were not with SME itself,
but were with Vivado. So is this an improvement to programming FPGAs using VHDL?
# - SME vs VHDL
# - How easy is FPGA programming
# - Future work
# - - SHA optimizations
# - ???

** SME as a tool for Software developers
# - How easy is FPGA programming
#+INCLUDE: "easyFPGA.org"
** Future work
Due to time limitations we didn't acomplish all we set out to do.
If given more time we would enable the pipelined versions of SHA-2 and MD5 to handle more than one block (448 bits) of data at a time.
This could be done by introducing a bus to forward the result of the final stage back into the start stage.
As showed previously this will be effective for small messages, but due to the overhead and the data dependency of SHA-2 and MD5,
it would not be better than the naive implementation.
#+CAPTION: A visualization of the pipeline stages of MD5 (SHA-2 is similar). The proposed bus is the dotted line.
#+LABEL: fig:MD5-pipe
[[./graphics/MD5-pipeline.png]]

# We also haven't made any pipelined versions of AES. Pipelining AES should be more doable and effective compared to SHA-2 and MD5.
# We have a design in mind, but it will require us to store the lookup tables used in AES in Block RAM on the FPGA.
# Doing so should not be a problem, since SME has an interface for it, but it is still a work in progess for us.
# The design is ...

# Måske er dette ikke nødvendigt
Having pipelined all of the functions in our crypto-library we could also test different implementations to find the fastest configurations.
As an example, our pipelined version of SHA-2 has it's 64 rounds split up into 4 stages with 16 rounds each.
Here testing could determine whether it is faster to have more stages with fewer rounds or vice versa.
As mentioned SHA-2 and MD5 are data dependant, so even our pipelined version needs to stall when the we are handling more than one block.
When the data is being processed in stages F-I in Figure \ref{MD5-pipe}, pipeline stalls. So the only time save is from the pipelined stages before the actual calculations.
So different sizes of the calculations stages in SHA-2 and MD5 might have some performance increases.
Also we could test out similar projects that is already documented, such as the one mentioned later in this section.

The next step after having finished the piplined versions will be creating a driver/interface to be able to communicate with the FPGA and call our functions in C.
We would print our implementation on the Zynq zedboard FPGA, the same architecture as we've tested on in Vivado.
Having the chip printed we would test it using a Raspberry Pi or similar low power ARM based controller.
The reason for this being that ARM doesn't have any accelerated instructions for any of the algorithms implemented\footnote{As an example, x86 has an instruction for AES, making it much faster than otherwise possible.}
To communicate between the Raspberry Pi and our FPGA, we'd need to create in interface, or driver, for it.
This driver should be determine signals used for communication and how data gets transfered between the two devices.
# However we do not have any specifications for this driver implementation,
# due to this being one of the final details for the project, and we do not have a finished implementation for our library.

# Teste om SHA skal opdeles yderligere?
# (v) Done
*** Known SHA256 improvements on FPGAs
#+INCLUDE: "SHAimprovements.org"
