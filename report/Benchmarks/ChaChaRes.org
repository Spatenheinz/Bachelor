** ChaCha20
\footnote{not entirely done}
#+BEGIN_EXPORT latex
\begin{table}[!htb]
\centering
\captionsetup{width=.8\linewidth}
\begin{tabular}{c c c c c c c c}
\hline
Version & f$_{max}$(Mhz) & clocks$_{high}$ & TP(MBps)$_{high}$ & clocks$_{low}$ & TP(MBps)$_{low}$ & LUT & FF\\
\hline
Naive  & 1.25 & b & 80 & b & 8 & 14670 & 3457
\end{tabular}
\caption[ChaCha20: FPGA Versions]%
{Performance and statistics over the different ChaCha implementations. f$_{max}$ is the clock rate reported from Vivado. Clocks describe how many clock cycles it takes to calculate \texttt{b} blocks, where high and low describe a best and worst-case scenario, respectively. The throughput (TP) is calculated as \((b_{bits}\cdot f_{max})/(clocks \cdot 8)\). LUT is the number of Look-Up Tables used in the design. FF is the reported amount of Flip Flops used. Proc$_{i}$ denotes how many ~i~ processes the 64 rounds are distributed over.}
\label{tab:ChaChaversions}
\end{table}
#+END_EXPORT
One would expect ChaCha to perform well, because of the simplicity in computation, the fact it was design for speed and that the OpenSSL as reported in Table \ref{tab:ChaChacompare} is more than 3 times faster than AES as shown in Table \ref{tab:AEScompare}. Despite this, our ChaCha solution cannot even be routed at 1 Mhz, which would correspond to a throughput of merely 64 MBps. This would be almost 5 times slower than OpenSSL on the Raspberry Pi.
#+BEGIN_EXPORT latex
\begin{table}[!htb]
\centering
\captionsetup{width=.8\linewidth}
\begin{tabular}{c c c c c}
\hline
\textbf{Version} & Naive & Proc & OpenSLL$_{low}$ & OpenSLL$_{high}$\\
\hline
\textbf{TP(MBps)} & 80 & ? & 84.03 & 306.81\\
 & & & X & X & X
\end{tabular}
\caption[ChaCha20: FPGA and CPU comparisons]%
{Performance comparison of the worst and best ChaCha FPGA implementations and the various CPU versions. The OpenSSL is from \texttt{openssl speed -evp chacha20}. Each of the CPU implementations has two values, the first being the Pi results and the second the I5 results.}
\label{tab:ChaChacompare}
\end{table}
#+END_EXPORT
 The culprit of ChaCha20's poor peformance is the high amount of nets. Nets is sythetic datapath in Vivado, which will be transformed into a wire when mapped to hardware. This suggests that we have too much data on the busses between the interlectual property (IP) and the register transfer level (RTL) of the design. This seems quite a reasonable argument as the input bus itself takes in 1152 bits and the output bus carries 544 bits to output the cipher.
 To have a more concrete proof of this we also implemented a version which only generates the keystream, meaning it performs all the quaterrounds but without doing the XOR with the plaintext. This reduces the input and output busses to 610 and 513 bits respectively. When routing the keystream version in Vivado we get a reported frequency of 200 Mhz. Thus there is a huge difference.\footnote{possibly not this bad but who knows}
