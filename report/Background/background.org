* Background

#+INCLUDE: "fpga.org"

#+INCLUDE: "SME.org"
** A crypto library
Cryptographic functions are used by developers across most branches, whether it'll be communicating securely over a network, or hashing programs to do version control.
So there is a motive for having a crypto library for FPGA's. In fact, such a processor has been made before. IBM created their own "IBM 4758 Secure Coprocessor"\cite{IBM4758}. Another point is modern Hardware security modules (HSM) which also does this.
However, the problem with the existing solutions is that many of them require setting up a royalty-based licensing deal, which makes it difficult to use for experimental development, small projects, and in research, and academics.
So we set out to create an open-source crypto library.

The crypto library consists of an implementation of various cryptographic functions, such as AES and SHA256. It should also have an API allowing users to utilize these functions in their projects, as they would with any other library.
These implementations should also be optimized in terms of speed so that they are competitive with the existing software solutions.
Creating a crypto library for FPGA's ...
*** Hashing
Hashing is a mathematical concept referring to using a hash function to map some data of arbitrary size to a value of a fixed size. Cryptographic hash functions are a subset of all hash functions.
The reason for this is that for a hash function to be a cryptographic hash function it needs to uphold several properties to ensure it is secure, such as ensuring that it is hard to find collisions. Computers also have limited space in memory which limits the implementation of hash functions. Lastly and most importantly, computers can't do true randomness.
If a hash function can be implemented with a limited input space, is pseudo-random, and upholds certain properties listed below, it can be categorized as a "Cryptographic Hash Function". One such example is the outdated MD5 algorithm.
- It should be deterministic, as it is important that the same hash is computed given some input.
- It is unreasonably hard to predict the hashed value. One reason for this is the requirement to exercise the avalanche effect, meaning the tiniest change in the input message would resolve in big changes in the hash.
- It is collision-resistant, meaning it is unreasonably hard to find two distinct messages to have the same hash.

**** Merkle-Damgård construction
One approach that is widely used in cryptographic hashing is the Merkle-Damgård construction. One of the reasons this approach is desirable when developing a cryptographic hashing algorithm is because the hash function will be collision-resistant given the compression function itself is collision-resistant.
From figure \ref{fig:Merkle} one can see the construction of the hashing function. One can see that the message will be padded to have a certain length since any compression function must work on static size. The compression function ~f~ will initially take two arguments, the initialization vector, and the first block. f will then produce a result of the same size as the initialization vector. This result will then be fed into the next iteration of ~f~ along with the second block of the message. This is repeated until the entire padded message has been processed. From here a potential finalization function can be used to improve the hash. Lastly, the hashed value will be produced.

#+CAPTION: Merkle-Damgård construction
#+LABEL: fig:Merkle
[[./merkle.png]]
*** Cypher
TODO: WRITE SOMETHING ABOUT CYPHERS

** MD5
:PROPERTIES:
:UNNUMBERED: nil
:CUSTOM_ID: MD5alg
:END:
#+INCLUDE: MD5.org
** AES
:PROPERTIES:
:UNNUMBERED: nil
:CUSTOM_ID: AESalg
:END:
#+INCLUDE: AES.org
