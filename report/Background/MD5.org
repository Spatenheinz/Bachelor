The Message-Digest algorithm MD5 is a reasonably simple one-way hashing function that produces a 128-bit digest specified in 1992 in RFC 1321\cite{rfc1321}. MD5 uses a Merkle-Damg√•rd construction.
The MD5 algorithm work by partition the input message into blocks of 512 bits. It is done by always padding the message with a single set bit followed by a series of 0's until the message = 448 mod 512. That is, even when the original message has a length of 448 mod 512, a 1 is followed by 511 bits of 0's.
Next, a 64-bit representation of the message length mod 2^64 is appended to the padded message.The padded message will be used to calculate the digest by mutating a 32-bit 4-word initialization vector (A, B, C, D), with the initial value:\\
~[~ ~A: 0x67542301~, ~B: 0xefcdab89~, ~C: 0x98badcfe~, ~D: 0x10325476~ ~]~\\
#+CAPTION: Two iterations of the MD5 rounds.
#+LABEL: fig:MD5
[[./Background/MD5rounds.png]]
Figure \ref{fig:MD5}, which expands the f from Figure \ref{fig:merkle} for MD5, shows the 4 rounds of a single 16-word block of the padded message.
It uses the following 4 functions, which is defined as such to, in "bitwise parallel" produce independent and unbiased bits in each of the rounds.
F(X, Y, Z) = XY \vee \neg X Z\\
G(X, Y, Z) = XZ \vee Y \neg Z\\
H(X, Y, Z) = X \oplus Y \oplus Z\\
I(X, Y, Z) = Y \oplus ( X \vee \neg Z)\\
Each round will consist of 16 applications of the function corresponding to that round. In the schema below one can see all of the function calls where ~[abcd k s i]~ denotes\\
~a = b + (( a + round(b,c,d) + M[k] + K[i]) \lll s)~, where ~round~ denotes the function corresponding to that round, ~M~ denotes the current 16-word buffer of the padded message and ~K[i]~ denotes the ~floor(2^32 * abs (sin(i + 1)))~.
#+BEGIN_SRC
round 1  :: F
[ABCD  0  7  1] [DABC  1 12  2] [CDAB  2 17  3] [BCDA  3 22  4]
[ABCD  4  7  5] [DABC  5 12  6] [CDAB  6 17  7] [BCDA  7 22  8]
[ABCD  8  7  9] [DABC  9 12 10] [CDAB 10 17 11] [BCDA 11 22 12]
[ABCD 12  7 13] [DABC 13 12 14] [CDAB 14 17 15] [BCDA 15 22 16]
Round 2 :: G
[ABCD  1  5 17] [DABC  6  9 18] [CDAB 11 14 19] [BCDA  0 20 20]
[ABCD  5  5 21] [DABC 10  9 22] [CDAB 15 14 23] [BCDA  4 20 24]
[ABCD  9  5 25] [DABC 14  9 26] [CDAB  3 14 27] [BCDA  8 20 28]
[ABCD 13  5 29] [DABC  2  9 30] [CDAB  7 14 31] [BCDA 12 20 32]
Round 3 :: H
[ABCD  5  4 33] [DABC  8 11 34] [CDAB 11 16 35] [BCDA 14 23 36]
[ABCD  1  4 37] [DABC  4 11 38] [CDAB  7 16 39] [BCDA 10 23 40]
[ABCD 13  4 41] [DABC  0 11 42] [CDAB  3 16 43] [BCDA  6 23 44]
[ABCD  9  4 45] [DABC 12 11 46] [CDAB 15 16 47] [BCDA  2 23 48]
Round 4 :: I
[ABCD  0  6 49] [DABC  7 10 50] [CDAB 14 15 51] [BCDA  5 21 52]
[ABCD 12  6 53] [DABC  3 10 54] [CDAB 10 15 55] [BCDA  1 21 56]
[ABCD  8  6 57] [DABC 15 10 58] [CDAB  6 15 59] [BCDA 13 21 60]
[ABCD  4  6 61] [DABC 11 10 62] [CDAB  2 15 63] [BCDA  9 21 64]
#+END_SRC
when all rounds have been completed the vector (A,B,C,D) will be added to the vector (A_o, B_o, C_o, D_o) as it was before the rounds. For instance if we are working on the first part of the padded message, the vector (A_o, B_o, C_o, D_o) would be the initialisation vector. The Digest will now be (A, B, C, D) in LE format. This vector will then be (A_o, B_o, C_o D_o) for the next iteration of MD5 which will be using the next block. when the MD5 iteration which corresponds to the last block of the padded message has been computed the IV will be (A,B,C,D).
It is worth noting that MD5 is not a very good hashing algorithm for cryptography, as collision attacks exist, despite the fact that it uses the merkle damgaard construction, but still show use for data integrity purposes and such.
